{"version":3,"file":"cornerstone.min.js","sources":["../src/internal/drawImage.js","../src/internal/modalityLUT.js","../src/internal/voiLUT.js","../src/internal/generateLut.js","../src/internal/getDefaultViewport.js","../src/internal/requestAnimationFrame.js","../src/internal/storedPixelDataToCanvasImageData.js","../src/internal/storedColorPixelDataToCanvasImageData.js","../src/internal/transform.js","../src/internal/calculateTransform.js","../src/setToPixelCoordinateSystem.js","../src/rendering/renderColorImage.js","../src/rendering/renderGrayscaleImage.js","../src/rendering/renderWebImage.js","../src/addEventListener.js","../src/enabledElements.js","../src/internal/getTransform.js","../src/canvasToPixel.js","../src/disable.js","../src/updateImage.js","../src/displayImage.js","../src/draw.js","../src/drawInvalidated.js","../src/fitToWindow.js","../src/resize.js","../src/enable.js","../src/enabledElementData.js","../src/getDefaultViewportForImage.js","../src/getImage.js","../src/getStoredPixels.js","../src/getPixels.js","../src/getViewport.js","../src/imageCache.js","../src/imageLoader.js","../src/invalidate.js","../src/invalidateImageId.js","../src/pageToPixel.js","../src/pixelToCanvas.js","../src/reset.js","../src/setViewport.js","../src/metaData.js","../src/cornerstone.js"],"sourcesContent":["/**\n * This module is responsible for drawing an image to an enabled elements canvas element\n */\n\n\n/**\n * Internal API function to draw an image to a given enabled element\n * @param enabledElement\n * @param invalidated - true if pixel data has been invalidated and cached rendering should not be used\n */\nexport function drawImage(enabledElement, invalidated) {\n    enabledElement.needsRedraw = true;\n    if (invalidated){\n        enabledElement.invalid = true;\n    }\n\n}\n","/**\n * This module generates a Modality LUT\n */\n\nfunction generateLinearModalityLUT(slope, intercept) {\n  var localSlope = slope;\n  var localIntercept = intercept;\n  return function(sp) {\n    return sp * localSlope + localIntercept;\n  }\n}\n\nfunction generateNonLinearModalityLUT(modalityLUT) {\n  var minValue = modalityLUT.lut[0];\n  var maxValue = modalityLUT.lut[modalityLUT.lut.length -1];\n  var maxValueMapped = modalityLUT.firstValueMapped + modalityLUT.lut.length;\n  return function(sp) {\n    if(sp < modalityLUT.firstValueMapped) {\n      return minValue;\n    }\n    else if(sp >= maxValueMapped)\n    {\n      return maxValue;\n    }\n    else\n    {\n      return modalityLUT.lut[sp];\n    }\n  }\n}\n\nexport function getModalityLUT(slope, intercept, modalityLUT) {\n  if (modalityLUT) {\n    return generateNonLinearModalityLUT(modalityLUT);\n  } else {\n    return generateLinearModalityLUT(slope, intercept);\n  }\n}\n","/**\n * This module generates a VOI LUT\n */\n\nfunction generateLinearVOILUT(windowWidth, windowCenter) {\n  return function(modalityLutValue) {\n    return (((modalityLutValue - (windowCenter)) / (windowWidth) + 0.5) * 255.0);\n  }\n}\n\nfunction generateNonLinearVOILUT(voiLUT) {\n  var shift = voiLUT.numBitsPerEntry - 8;\n  var minValue = voiLUT.lut[0] >> shift;\n  var maxValue = voiLUT.lut[voiLUT.lut.length -1] >> shift;\n  var maxValueMapped = voiLUT.firstValueMapped + voiLUT.lut.length - 1;\n  return function(modalityLutValue) {\n    if(modalityLutValue < voiLUT.firstValueMapped) {\n      return minValue;\n    }\n    else if(modalityLutValue >= maxValueMapped)\n    {\n      return maxValue;\n    }\n    else\n    {\n      return voiLUT.lut[modalityLutValue - voiLUT.firstValueMapped] >> shift;\n    }\n  }\n}\n\nexport function getVOILUT(windowWidth, windowCenter, voiLUT) {\n  if(voiLUT) {\n    return generateNonLinearVOILUT(voiLUT);\n  } else {\n    return generateLinearVOILUT(windowWidth, windowCenter);\n  }\n}\n","/**\n * This module generates a lut for an image\n */\n\nimport { getModalityLUT } from './modalityLUT.js';\nimport { getVOILUT } from './voiLUT.js';\n\nexport function generateLutNew(image, windowWidth, windowCenter, invert, modalityLUT, voiLUT)\n{\n  if(image.lut === undefined) {\n    image.lut =  new Int16Array(image.maxPixelValue - Math.min(image.minPixelValue,0)+1);\n  }\n  var lut = image.lut;\n  var maxPixelValue = image.maxPixelValue;\n  var minPixelValue = image.minPixelValue;\n\n  var mlutfn = getModalityLUT(image.slope, image.intercept, modalityLUT);\n  var vlutfn = getVOILUT(windowWidth, windowCenter, voiLUT);\n\n  var offset = 0;\n  if(minPixelValue < 0) {\n    offset = minPixelValue;\n  }\n  var storedValue;\n  var modalityLutValue;\n  var voiLutValue;\n  var clampedValue;\n\n  for(storedValue = image.minPixelValue; storedValue <= maxPixelValue; storedValue++)\n  {\n    modalityLutValue = mlutfn(storedValue);\n    voiLutValue = vlutfn(modalityLutValue);\n    clampedValue = Math.min(Math.max(voiLutValue, 0), 255);\n    if(!invert) {\n      lut[storedValue+ (-offset)] = Math.round(clampedValue);\n    } else {\n      lut[storedValue + (-offset)] = Math.round(255 - clampedValue);\n    }\n  }\n  return lut;\n}\n\n\n\n/**\n * Creates a LUT used while rendering to convert stored pixel values to\n * display pixels\n *\n * @param image\n * @returns {Array}\n */\nexport function generateLut(image, windowWidth, windowCenter, invert, modalityLUT, voiLUT)\n{\n  if(modalityLUT || voiLUT) {\n    return generateLutNew(image, windowWidth, windowCenter, invert, modalityLUT, voiLUT);\n  }\n\n  if(image.lut === undefined) {\n    image.lut =  new Int16Array(image.maxPixelValue - Math.min(image.minPixelValue,0)+1);\n  }\n  var lut = image.lut;\n\n  var maxPixelValue = image.maxPixelValue;\n  var minPixelValue = image.minPixelValue;\n  var slope = image.slope;\n  var intercept = image.intercept;\n  var localWindowWidth = windowWidth;\n  var localWindowCenter = windowCenter;\n  var modalityLutValue;\n  var voiLutValue;\n  var clampedValue;\n  var storedValue;\n\n  // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n  // We improve performance by offsetting the pixel values for signed data to avoid negative indexes\n  // when generating the lut and then undo it in storedPixelDataToCanvasImagedata.  Thanks to @jpambrun\n  // for this contribution!\n\n  var offset = 0;\n  if(minPixelValue < 0) {\n    offset = minPixelValue;\n  }\n\n  if(invert === true) {\n    for(storedValue = image.minPixelValue; storedValue <= maxPixelValue; storedValue++)\n    {\n      modalityLutValue =  storedValue * slope + intercept;\n      voiLutValue = (((modalityLutValue - (localWindowCenter)) / (localWindowWidth) + 0.5) * 255.0);\n      clampedValue = Math.min(Math.max(voiLutValue, 0), 255);\n      lut[storedValue + (-offset)] = Math.round(255 - clampedValue);\n    }\n  }\n  else {\n    for(storedValue = image.minPixelValue; storedValue <= maxPixelValue; storedValue++)\n    {\n      modalityLutValue = storedValue * slope + intercept;\n      voiLutValue = (((modalityLutValue - (localWindowCenter)) / (localWindowWidth) + 0.5) * 255.0);\n      clampedValue = Math.min(Math.max(voiLutValue, 0), 255);\n      lut[storedValue+ (-offset)] = Math.round(clampedValue);\n    }\n  }\n}\n","/**\n * This module contains a function to get a default viewport for an image given\n * a canvas element to display it in\n *\n */\n\n/**\n * Creates a new viewport object containing default values for the image and canvas\n * @param canvas\n * @param image\n * @returns viewport object\n */\nexport function getDefaultViewport(canvas, image) {\n    if(canvas === undefined) {\n        throw \"getDefaultViewport: parameter canvas must not be undefined\";\n    }\n    if(image === undefined) {\n        throw \"getDefaultViewport: parameter image must not be undefined\";\n    }\n    var viewport = {\n        scale : 1.0,\n        translation : {\n            x : 0,\n            y : 0\n        },\n        voi : {\n            windowWidth: image.windowWidth,\n            windowCenter: image.windowCenter,\n        },\n        invert: image.invert,\n        pixelReplication: false,\n        rotation: 0,\n        hflip: false,\n        vflip: false,\n        modalityLUT: image.modalityLUT,\n        voiLUT: image.voiLUT\n    };\n\n    // fit image to window\n    var verticalScale = canvas.height / image.rows;\n    var horizontalScale= canvas.width / image.columns;\n    if(horizontalScale < verticalScale) {\n        viewport.scale = horizontalScale;\n    }\n    else {\n        viewport.scale = verticalScale;\n    }\n    return viewport;\n}\n","/**\n * This module polyfills requestAnimationFrame for older browsers.\n */\n\nfunction requestFrame(callback) {\n  window.setTimeout(callback, 1000 / 60);\n}\n\nexport function requestAnimationFrame(callback) {\n  return window.requestAnimationFrame(callback) ||\n    window.webkitRequestAnimationFrame(callback) ||\n    window.mozRequestAnimationFrame(callback) ||\n    window.oRequestAnimationFrame(callback) ||\n    window.msRequestAnimationFrame(callback) ||\n    requestFrame(callback);\n}\n","/**\n * This module contains a function to convert stored pixel values to display pixel values using a LUT\n */\n\n/**\n * This function transforms stored pixel values into a canvas image data buffer\n * by using a LUT.  This is the most performance sensitive code in cornerstone and\n * we use a special trick to make this go as fast as possible.  Specifically we\n * use the alpha channel only to control the luminance rather than the red, green and\n * blue channels which makes it over 3x faster.  The canvasImageDataData buffer needs\n * to be previously filled with white pixels.\n *\n * NOTE: Attribution would be appreciated if you use this technique!\n *\n * @param pixelData the pixel data\n * @param lut the lut\n * @param canvasImageDataData a canvasImgageData.data buffer filled with white pixels\n */\nexport function storedPixelDataToCanvasImageData(image, lut, canvasImageDataData)\n{\n    var pixelData = image.getPixelData();\n    var minPixelValue = image.minPixelValue;\n    var canvasImageDataIndex = 3;\n    var storedPixelDataIndex = 0;\n    var localNumPixels = pixelData.length;\n    var localPixelData = pixelData;\n    var localLut = lut;\n    var localCanvasImageDataData = canvasImageDataData;\n    // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n    // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n    if(minPixelValue < 0){\n        while(storedPixelDataIndex < localNumPixels) {\n            localCanvasImageDataData[canvasImageDataIndex] = localLut[localPixelData[storedPixelDataIndex++] + (-minPixelValue)]; // alpha\n            canvasImageDataIndex += 4;\n        }\n    }else{\n        while(storedPixelDataIndex < localNumPixels) {\n            localCanvasImageDataData[canvasImageDataIndex] = localLut[localPixelData[storedPixelDataIndex++]]; // alpha\n            canvasImageDataIndex += 4;\n        }\n    }\n}\n","/**\n * This module contains a function to convert stored pixel values to display pixel values using a LUT\n */\n\nexport function storedColorPixelDataToCanvasImageData(image, lut, canvasImageDataData)\n{\n    var minPixelValue = image.minPixelValue;\n    var canvasImageDataIndex = 0;\n    var storedPixelDataIndex = 0;\n    var numPixels = image.width * image.height * 4;\n    var storedPixelData = image.getPixelData();\n    var localLut = lut;\n    var localCanvasImageDataData = canvasImageDataData;\n    // NOTE: As of Nov 2014, most javascript engines have lower performance when indexing negative indexes.\n    // We have a special code path for this case that improves performance.  Thanks to @jpambrun for this enhancement\n    if(minPixelValue < 0){\n        while(storedPixelDataIndex < numPixels) {\n            localCanvasImageDataData[canvasImageDataIndex++] = localLut[storedPixelData[storedPixelDataIndex++] + (-minPixelValue)]; // red\n            localCanvasImageDataData[canvasImageDataIndex++] = localLut[storedPixelData[storedPixelDataIndex++] + (-minPixelValue)]; // green\n            localCanvasImageDataData[canvasImageDataIndex] = localLut[storedPixelData[storedPixelDataIndex] + (-minPixelValue)]; // blue\n            storedPixelDataIndex+=2;\n            canvasImageDataIndex+=2;\n        }\n    } else {\n        while(storedPixelDataIndex < numPixels) {\n            localCanvasImageDataData[canvasImageDataIndex++] = localLut[storedPixelData[storedPixelDataIndex++]]; // red\n            localCanvasImageDataData[canvasImageDataIndex++] = localLut[storedPixelData[storedPixelDataIndex++]]; // green\n            localCanvasImageDataData[canvasImageDataIndex] = localLut[storedPixelData[storedPixelDataIndex]]; // blue\n            storedPixelDataIndex+=2;\n            canvasImageDataIndex+=2;\n        }\n    }\n}\n","// Last updated November 2011\n// By Simon Sarris\n// www.simonsarris.com\n// sarris@acm.org\n//\n// Free to use and distribute at will\n// So long as you are nice to people, etc\n\n// Simple class for keeping track of the current transformation matrix\n\n// For instance:\n//    var t = new Transform();\n//    t.rotate(5);\n//    var m = t.m;\n//    ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\n// Is equivalent to:\n//    ctx.rotate(5);\n\n// But now you can retrieve it :)\n\n\n// Remember that this does not account for any CSS transforms applied to the canvas\nexport function Transform() {\n    this.reset();\n}\n\nTransform.prototype.reset = function() {\n    this.m = [1,0,0,1,0,0];\n};\n\nTransform.prototype.clone = function() {\n    var transform = new Transform();\n    transform.m[0] = this.m[0];\n    transform.m[1] = this.m[1];\n    transform.m[2] = this.m[2];\n    transform.m[3] = this.m[3];\n    transform.m[4] = this.m[4];\n    transform.m[5] = this.m[5];\n    return transform;\n};\n\n\nTransform.prototype.multiply = function(matrix) {\n    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];\n    var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];\n\n    var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];\n    var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];\n\n    var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];\n    var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];\n\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    this.m[4] = dx;\n    this.m[5] = dy;\n};\n\nTransform.prototype.invert = function() {\n    var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);\n    var m0 = this.m[3] * d;\n    var m1 = -this.m[1] * d;\n    var m2 = -this.m[2] * d;\n    var m3 = this.m[0] * d;\n    var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);\n    var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);\n    this.m[0] = m0;\n    this.m[1] = m1;\n    this.m[2] = m2;\n    this.m[3] = m3;\n    this.m[4] = m4;\n    this.m[5] = m5;\n};\n\nTransform.prototype.rotate = function(rad) {\n    var c = Math.cos(rad);\n    var s = Math.sin(rad);\n    var m11 = this.m[0] * c + this.m[2] * s;\n    var m12 = this.m[1] * c + this.m[3] * s;\n    var m21 = this.m[0] * -s + this.m[2] * c;\n    var m22 = this.m[1] * -s + this.m[3] * c;\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n};\n\nTransform.prototype.translate = function(x, y) {\n    this.m[4] += this.m[0] * x + this.m[2] * y;\n    this.m[5] += this.m[1] * x + this.m[3] * y;\n};\n\nTransform.prototype.scale = function(sx, sy) {\n    this.m[0] *= sx;\n    this.m[1] *= sx;\n    this.m[2] *= sy;\n    this.m[3] *= sy;\n};\n\nTransform.prototype.transformPoint = function(px, py) {\n    var x = px;\n    var y = py;\n    px = x * this.m[0] + y * this.m[2] + this.m[4];\n    py = x * this.m[1] + y * this.m[3] + this.m[5];\n    return {x: px, y: py};\n};\n","import { Transform } from './transform.js';\n\nexport function calculateTransform(enabledElement, scale) {\n\n    var transform = new Transform();\n    transform.translate(enabledElement.canvas.width/2, enabledElement.canvas.height / 2);\n\n    //Apply the rotation before scaling for non square pixels\n    var angle = enabledElement.viewport.rotation;\n    if(angle!==0) {\n        transform.rotate(angle*Math.PI/180);\n    }\n\n    // apply the scale\n    var widthScale = enabledElement.viewport.scale;\n    var heightScale = enabledElement.viewport.scale;\n    if(enabledElement.image.rowPixelSpacing < enabledElement.image.columnPixelSpacing) {\n        widthScale = widthScale * (enabledElement.image.columnPixelSpacing / enabledElement.image.rowPixelSpacing);\n    }\n    else if(enabledElement.image.columnPixelSpacing < enabledElement.image.rowPixelSpacing) {\n        heightScale = heightScale * (enabledElement.image.rowPixelSpacing / enabledElement.image.columnPixelSpacing);\n    }\n    transform.scale(widthScale, heightScale);\n\n    // unrotate to so we can translate unrotated\n    if(angle!==0) {\n        transform.rotate(-angle*Math.PI/180);\n    }\n\n    // apply the pan offset\n    transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);\n\n    // rotate again so we can apply general scale\n    if(angle!==0) {\n        transform.rotate(angle*Math.PI/180);\n    }\n\n    if(scale !== undefined) {\n        // apply the font scale\n        transform.scale(scale, scale);\n    }\n\n    //Apply Flip if required\n    if(enabledElement.viewport.hflip) {\n        transform.scale(-1,1);\n    }\n\n    if(enabledElement.viewport.vflip) {\n        transform.scale(1,-1);\n    }\n\n    // translate the origin back to the corner of the image so the event handlers can draw in image coordinate system\n    transform.translate(-enabledElement.image.width / 2 , -enabledElement.image.height/ 2);\n    return transform;\n}\n","/**\n * This module contains a function that will set the canvas context to the pixel coordinates system\n * making it easy to draw geometry on the image\n */\n\nimport { calculateTransform } from './internal/calculateTransform.js';\n\n/**\n * Sets the canvas context transformation matrix to the pixel coordinate system.  This allows\n * geometry to be driven using the canvas context using coordinates in the pixel coordinate system\n * @param ee\n * @param context\n * @param scale optional scaler to apply\n */\nexport function setToPixelCoordinateSystem(enabledElement, context, scale)\n{\n    if(enabledElement === undefined) {\n        throw \"setToPixelCoordinateSystem: parameter enabledElement must not be undefined\";\n    }\n    if(context === undefined) {\n        throw \"setToPixelCoordinateSystem: parameter context must not be undefined\";\n    }\n\n    var transform = calculateTransform(enabledElement, scale);\n    context.setTransform(transform.m[0],transform.m[1],transform.m[2],transform.m[3],transform.m[4],transform.m[5]);\n}\n","/**\n * This module is responsible for drawing an image to an enabled elements canvas element\n */\nimport { generateLut } from '../internal/generateLut.js';\nimport { storedColorPixelDataToCanvasImageData } from '../internal/storedColorPixelDataToCanvasImageData';\nimport { setToPixelCoordinateSystem } from '../setToPixelCoordinateSystem';\n\nvar colorRenderCanvas = document.createElement('canvas');\nvar colorRenderCanvasContext;\nvar colorRenderCanvasData;\n\nvar lastRenderedImageId;\nvar lastRenderedViewport = {};\n\nfunction initializeColorRenderCanvas(image)\n{\n    // Resize the canvas\n    colorRenderCanvas.width = image.width;\n    colorRenderCanvas.height = image.height;\n\n    // get the canvas data so we can write to it directly\n    colorRenderCanvasContext = colorRenderCanvas.getContext('2d');\n    colorRenderCanvasContext.fillStyle = 'white';\n    colorRenderCanvasContext.fillRect(0,0, colorRenderCanvas.width, colorRenderCanvas.height);\n    colorRenderCanvasData = colorRenderCanvasContext.getImageData(0,0,image.width, image.height);\n}\n\n\nfunction getLut(image, viewport)\n{\n    // if we have a cached lut and it has the right values, return it immediately\n    if(image.lut !== undefined &&\n        image.lut.windowCenter === viewport.voi.windowCenter &&\n        image.lut.windowWidth === viewport.voi.windowWidth &&\n        image.lut.invert === viewport.invert) {\n        return image.lut;\n    }\n\n    // lut is invalid or not present, regenerate it and cache it\n    generateLut(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert);\n    image.lut.windowWidth = viewport.voi.windowWidth;\n    image.lut.windowCenter = viewport.voi.windowCenter;\n    image.lut.invert = viewport.invert;\n    return image.lut;\n}\n\nfunction doesImageNeedToBeRendered(enabledElement, image)\n{\n    if(image.imageId !== lastRenderedImageId ||\n        lastRenderedViewport.windowCenter !== enabledElement.viewport.voi.windowCenter ||\n        lastRenderedViewport.windowWidth !== enabledElement.viewport.voi.windowWidth ||\n        lastRenderedViewport.invert !== enabledElement.viewport.invert ||\n        lastRenderedViewport.rotation !== enabledElement.viewport.rotation ||\n        lastRenderedViewport.hflip !== enabledElement.viewport.hflip ||\n        lastRenderedViewport.vflip !== enabledElement.viewport.vflip\n        )\n    {\n        return true;\n    }\n\n    return false;\n}\n\nfunction getRenderCanvas(enabledElement, image, invalidated)\n{\n\n    // The ww/wc is identity and not inverted - get a canvas with the image rendered into it for\n    // fast drawing\n    if(enabledElement.viewport.voi.windowWidth === 255 &&\n        enabledElement.viewport.voi.windowCenter === 128 &&\n        enabledElement.viewport.invert === false &&\n        image.getCanvas &&\n        image.getCanvas()\n    )\n    {\n        return image.getCanvas();\n    }\n\n    // apply the lut to the stored pixel data onto the render canvas\n    if(doesImageNeedToBeRendered(enabledElement, image) === false && invalidated !== true) {\n        return colorRenderCanvas;\n    }\n\n    // If our render canvas does not match the size of this image reset it\n    // NOTE: This might be inefficient if we are updating multiple images of different\n    // sizes frequently.\n    if(colorRenderCanvas.width !== image.width || colorRenderCanvas.height != image.height) {\n        initializeColorRenderCanvas(image);\n    }\n\n    // get the lut to use\n    var colorLut = getLut(image, enabledElement.viewport);\n\n    // the color image voi/invert has been modified - apply the lut to the underlying\n    // pixel data and put it into the renderCanvas\n    storedColorPixelDataToCanvasImageData(image, colorLut, colorRenderCanvasData.data);\n    colorRenderCanvasContext.putImageData(colorRenderCanvasData, 0, 0);\n    return colorRenderCanvas;\n}\n\n/**\n * API function to render a color image to an enabled element\n * @param enabledElement\n * @param invalidated - true if pixel data has been invaldiated and cached rendering should not be used\n */\nexport function renderColorImage(enabledElement, invalidated) {\n\n    if(enabledElement === undefined) {\n        throw \"drawImage: enabledElement parameter must not be undefined\";\n    }\n    var image = enabledElement.image;\n    if(image === undefined) {\n        throw \"drawImage: image must be loaded before it can be drawn\";\n    }\n\n    // get the canvas context and reset the transform\n    var context = enabledElement.canvas.getContext('2d');\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // clear the canvas\n    context.fillStyle = 'black';\n    context.fillRect(0,0, enabledElement.canvas.width, enabledElement.canvas.height);\n\n    // turn off image smooth/interpolation if pixelReplication is set in the viewport\n    if(enabledElement.viewport.pixelReplication === true) {\n        context.imageSmoothingEnabled = false;\n        context.mozImageSmoothingEnabled = false; // firefox doesn't support imageSmoothingEnabled yet\n    }\n    else {\n        context.imageSmoothingEnabled = true;\n        context.mozImageSmoothingEnabled = true;\n    }\n\n    // save the canvas context state and apply the viewport properties\n    context.save();\n    setToPixelCoordinateSystem(enabledElement, context);\n\n    var renderCanvas = getRenderCanvas(enabledElement, image, invalidated);\n\n    context.drawImage(renderCanvas, 0,0, image.width, image.height, 0, 0, image.width, image.height);\n\n    context.restore();\n\n    lastRenderedImageId = image.imageId;\n    lastRenderedViewport.windowCenter = enabledElement.viewport.voi.windowCenter;\n    lastRenderedViewport.windowWidth = enabledElement.viewport.voi.windowWidth;\n    lastRenderedViewport.invert = enabledElement.viewport.invert;\n    lastRenderedViewport.rotation = enabledElement.viewport.rotation;\n    lastRenderedViewport.hflip = enabledElement.viewport.hflip;\n    lastRenderedViewport.vflip = enabledElement.viewport.vflip;\n}\n","/**\n * This module is responsible for drawing a grayscale imageÃŸ\n */\nimport { generateLut } from '../internal/generateLut.js';\nimport { storedPixelDataToCanvasImageData } from '../internal/storedPixelDataToCanvasImageData';\nimport { setToPixelCoordinateSystem } from '../setToPixelCoordinateSystem';\n\nvar grayscaleRenderCanvas = document.createElement('canvas');\nvar grayscaleRenderCanvasContext;\nvar grayscaleRenderCanvasData;\n\nvar lastRenderedImageId;\nvar lastRenderedViewport = {};\n\nfunction initializeGrayscaleRenderCanvas(image)\n{\n    // Resize the canvas\n    grayscaleRenderCanvas.width = image.width;\n    grayscaleRenderCanvas.height = image.height;\n\n    // NOTE - we need to fill the render canvas with white pixels since we control the luminance\n    // using the alpha channel to improve rendering performance.\n    grayscaleRenderCanvasContext = grayscaleRenderCanvas.getContext('2d');\n    grayscaleRenderCanvasContext.fillStyle = 'white';\n    grayscaleRenderCanvasContext.fillRect(0,0, grayscaleRenderCanvas.width, grayscaleRenderCanvas.height);\n    grayscaleRenderCanvasData = grayscaleRenderCanvasContext.getImageData(0,0,image.width, image.height);\n}\n\nfunction lutMatches(a, b) {\n  // if undefined, they are equal\n  if(!a && !b) {\n    return true;\n  }\n  // if one is undefined, not equal\n  if(!a || !b) {\n    return false;\n  }\n  // check the unique ids\n  return (a.id === b.id)\n}\n\nfunction getLut(image, viewport, invalidated)\n{\n    // if we have a cached lut and it has the right values, return it immediately\n    if(image.lut !== undefined &&\n        image.lut.windowCenter === viewport.voi.windowCenter &&\n        image.lut.windowWidth === viewport.voi.windowWidth &&\n        lutMatches(image.lut.modalityLUT, viewport.modalityLUT) &&\n        lutMatches(image.lut.voiLUT, viewport.voiLUT) &&\n        image.lut.invert === viewport.invert &&\n        invalidated !== true) {\n        return image.lut;\n    }\n\n    // lut is invalid or not present, regenerate it and cache it\n    generateLut(image, viewport.voi.windowWidth, viewport.voi.windowCenter, viewport.invert, viewport.modalityLUT, viewport.voiLUT);\n    image.lut.windowWidth = viewport.voi.windowWidth;\n    image.lut.windowCenter = viewport.voi.windowCenter;\n    image.lut.invert = viewport.invert;\n    image.lut.voiLUT = viewport.voiLUT;\n    image.lut.modalityLUT = viewport.modalityLUT;\n    return image.lut;\n}\n\nfunction doesImageNeedToBeRendered(enabledElement, image)\n{\n    if(image.imageId !== lastRenderedImageId ||\n        lastRenderedViewport.windowCenter !== enabledElement.viewport.voi.windowCenter ||\n        lastRenderedViewport.windowWidth !== enabledElement.viewport.voi.windowWidth ||\n        lastRenderedViewport.invert !== enabledElement.viewport.invert ||\n        lastRenderedViewport.rotation !== enabledElement.viewport.rotation ||\n        lastRenderedViewport.hflip !== enabledElement.viewport.hflip ||\n        lastRenderedViewport.vflip !== enabledElement.viewport.vflip ||\n        lastRenderedViewport.modalityLUT !== enabledElement.viewport.modalityLUT ||\n        lastRenderedViewport.voiLUT !== enabledElement.viewport.voiLUT\n        )\n    {\n        return true;\n    }\n\n    return false;\n}\n\nfunction getRenderCanvas(enabledElement, image, invalidated)\n{\n    // apply the lut to the stored pixel data onto the render canvas\n\n    if(doesImageNeedToBeRendered(enabledElement, image) === false && invalidated !== true) {\n        return grayscaleRenderCanvas;\n    }\n\n    // If our render canvas does not match the size of this image reset it\n    // NOTE: This might be inefficient if we are updating multiple images of different\n    // sizes frequently.\n    if(grayscaleRenderCanvas.width !== image.width || grayscaleRenderCanvas.height != image.height) {\n        initializeGrayscaleRenderCanvas(image);\n    }\n\n    // get the lut to use\n    var lut = getLut(image, enabledElement.viewport, invalidated);\n    // gray scale image - apply the lut and put the resulting image onto the render canvas\n    storedPixelDataToCanvasImageData(image, lut, grayscaleRenderCanvasData.data);\n    grayscaleRenderCanvasContext.putImageData(grayscaleRenderCanvasData, 0, 0);\n    return grayscaleRenderCanvas;\n}\n\n/**\n * API function to draw a grayscale image to a given enabledElement\n * @param enabledElement\n * @param invalidated - true if pixel data has been invaldiated and cached rendering should not be used\n */\nexport function renderGrayscaleImage(enabledElement, invalidated) {\n\n    if(enabledElement === undefined) {\n        throw \"drawImage: enabledElement parameter must not be undefined\";\n    }\n    var image = enabledElement.image;\n    if(image === undefined) {\n        throw \"drawImage: image must be loaded before it can be drawn\";\n    }\n\n    // get the canvas context and reset the transform\n    var context = enabledElement.canvas.getContext('2d');\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // clear the canvas\n    context.fillStyle = 'black';\n    context.fillRect(0,0, enabledElement.canvas.width, enabledElement.canvas.height);\n\n    // turn off image smooth/interpolation if pixelReplication is set in the viewport\n    if(enabledElement.viewport.pixelReplication === true) {\n        context.imageSmoothingEnabled = false;\n        context.mozImageSmoothingEnabled = false; // firefox doesn't support imageSmoothingEnabled yet\n    }\n    else {\n        context.imageSmoothingEnabled = true;\n        context.mozImageSmoothingEnabled = true;\n    }\n\n    // save the canvas context state and apply the viewport properties\n    setToPixelCoordinateSystem(enabledElement, context);\n\n    var renderCanvas = getRenderCanvas(enabledElement, image, invalidated);\n\n    // Draw the render canvas half the image size (because we set origin to the middle of the canvas above)\n    context.drawImage(renderCanvas, 0,0, image.width, image.height, 0, 0, image.width, image.height);\n\n    lastRenderedImageId = image.imageId;\n    lastRenderedViewport.windowCenter = enabledElement.viewport.voi.windowCenter;\n    lastRenderedViewport.windowWidth = enabledElement.viewport.voi.windowWidth;\n    lastRenderedViewport.invert = enabledElement.viewport.invert;\n    lastRenderedViewport.rotation = enabledElement.viewport.rotation;\n    lastRenderedViewport.hflip = enabledElement.viewport.hflip;\n    lastRenderedViewport.vflip = enabledElement.viewport.vflip;\n    lastRenderedViewport.modalityLUT = enabledElement.viewport.modalityLUT;\n    lastRenderedViewport.voiLUT = enabledElement.viewport.voiLUT;\n}\n","/**\n * This module is responsible for drawing an image to an enabled elements canvas element\n */\nimport { setToPixelCoordinateSystem } from '../setToPixelCoordinateSystem';\nimport { renderColorImage } from './renderColorImage';\n\n/**\n * API function to draw a standard web image (PNG, JPG) to an enabledImage\n *\n * @param enabledElement\n * @param invalidated - true if pixel data has been invaldiated and cached rendering should not be used\n */\nexport function renderWebImage(enabledElement, invalidated) {\n\n    if(enabledElement === undefined) {\n        throw \"drawImage: enabledElement parameter must not be undefined\";\n    }\n    var image = enabledElement.image;\n    if(image === undefined) {\n        throw \"drawImage: image must be loaded before it can be drawn\";\n    }\n\n    // get the canvas context and reset the transform\n    var context = enabledElement.canvas.getContext('2d');\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // clear the canvas\n    context.fillStyle = 'black';\n    context.fillRect(0,0, enabledElement.canvas.width, enabledElement.canvas.height);\n\n    // turn off image smooth/interpolation if pixelReplication is set in the viewport\n    if(enabledElement.viewport.pixelReplication === true) {\n        context.imageSmoothingEnabled = false;\n        context.mozImageSmoothingEnabled = false; // firefox doesn't support imageSmoothingEnabled yet\n    }\n    else {\n        context.imageSmoothingEnabled = true;\n        context.mozImageSmoothingEnabled = true;\n    }\n\n    // save the canvas context state and apply the viewport properties\n    setToPixelCoordinateSystem(enabledElement, context);\n\n    // if the viewport ww/wc and invert all match the initial state of the image, we can draw the image\n    // directly.  If any of those are changed, we call renderColorImage() to apply the lut\n    if(enabledElement.viewport.voi.windowWidth === enabledElement.image.windowWidth &&\n        enabledElement.viewport.voi.windowCenter === enabledElement.image.windowCenter &&\n        enabledElement.viewport.invert === false)\n    {\n        context.drawImage(image.getImage(), 0, 0, image.width, image.height, 0, 0, image.width, image.height);\n    } else {\n        renderColorImage(enabledElement, invalidated);\n    }\n\n}\n","/**\n * This module deals with ImageLoaders, loading images and caching images\n */\n\nvar eventTypes = {};\n\n// Registers an event listener\nexport function addEventListener(type, callback) {\n    var eventListeners = eventTypes[type] || [];\n    eventListeners.push(callback);\n    eventTypes[type] = eventListeners;\n}\n\n// Dispatches an event\nexport function dispatchEvent(type, data) {\n    var eventListeners = eventTypes[type];\n\n    if (!eventListeners || eventListeners.length < 1) {\n        return;\n    }\n\n    for (var i = 0; i < eventListeners.length; i++) {\n        eventListeners[i](data);\n    }\n}\n","var enabledElements = [];\n\nexport function getEnabledElement(element) {\n    if(element === undefined) {\n        throw \"getEnabledElement: parameter element must not be undefined\";\n    }\n    for(var i=0; i < enabledElements.length; i++) {\n        if(enabledElements[i].element == element) {\n            return enabledElements[i];\n        }\n    }\n\n    throw \"element not enabled\";\n}\n\nexport function addEnabledElement(enabledElement) {\n    if(enabledElement === undefined) {\n        throw \"getEnabledElement: enabledElement element must not be undefined\";\n    }\n\n    enabledElements.push(enabledElement);\n}\n\nexport function getEnabledElementsByImageId(imageId) {\n    var ees = [];\n    enabledElements.forEach(function(enabledElement) {\n        if(enabledElement.image && enabledElement.image.imageId === imageId) {\n            ees.push(enabledElement);\n        }\n    });\n    return ees;\n}\n\nexport function getEnabledElements() {\n    return enabledElements;\n}\n","import { calculateTransform } from './calculateTransform.js';\n\nexport function getTransform(enabledElement)\n{\n    // For now we will calculate it every time it is requested.  In the future, we may want to cache\n    // it in the enabled element to speed things up\n    var transform = calculateTransform(enabledElement);\n    return transform;\n}\n","import { getEnabledElement } from './enabledElements.js';\nimport { getTransform } from './internal/getTransform.js';\n\n/**\n * Converts a point in the canvas coordinate system to the pixel coordinate system\n * system.  This can be used to reset tools' image coordinates after modifications\n * have been made in canvas space (e.g. moving a tool by a few cm, independent of\n * image resolution).\n *\n * @param element\n * @param pt\n * @returns {x: number, y: number}\n */\nexport function canvasToPixel(element, pt) {\n    var enabledElement = getEnabledElement(element);\n    var transform = getTransform(enabledElement);\n    transform.invert();\n    return transform.transformPoint(pt.x, pt.y);\n}\n","import { getEnabledElements } from './enabledElements.js';\n\nexport function disable(element) {\n  if(element === undefined) {\n      throw \"disable: element element must not be undefined\";\n  }\n\n  // Search for this element in this list of enabled elements\n  var enabledElements = getEnabledElements();\n  for(var i=0; i < enabledElements.length; i++) {\n      if(enabledElements[i].element === element) {\n          // We found it!\n\n          // Fire an event so dependencies can cleanup\n          var eventData = {\n              element : element\n          };\n          var event = new CustomEvent(\"CornerstoneElementDisabled\", {detail: eventData});\n          element.dispatchEvent(event);\n\n          // remove the child dom elements that we created (e.g.canvas)\n          enabledElements[i].element.removeChild(enabledElements[i].canvas);\n          enabledElements[i].canvas = undefined;\n\n          // remove this element from the list of enabled elements\n          enabledElements.splice(i, 1);\n          return;\n      }\n  }\n}\n","import { getEnabledElement } from './enabledElements.js';\nimport { drawImage } from './internal/drawImage.js';\n\n/**\n * This module contains a function to immediately redraw an image\n */\n/**\n * Forces the image to be updated/redrawn for the specified enabled element\n * @param element\n */\nexport function updateImage(element, invalidated) {\n    var enabledElement = getEnabledElement(element);\n\n    if(enabledElement.image === undefined) {\n        throw \"updateImage: image has not been loaded yet\";\n    }\n\n    drawImage(enabledElement, invalidated);\n}\n","/**\n * This module is responsible for enabling an element to display images with cornerstone\n */\n\nimport { getEnabledElement } from './enabledElements.js';\nimport { getDefaultViewport } from './internal/getDefaultViewport.js';\nimport { updateImage } from './updateImage.js';\n\n/**\n * sets a new image object for a given element\n * @param element\n * @param image\n */\nexport function displayImage(element, image, viewport) {\n    if(element === undefined) {\n        throw \"displayImage: parameter element cannot be undefined\";\n    }\n    if(image === undefined) {\n        throw \"displayImage: parameter image cannot be undefined\";\n    }\n\n    var enabledElement = getEnabledElement(element);\n\n    enabledElement.image = image;\n\n    if(enabledElement.viewport === undefined) {\n        enabledElement.viewport = getDefaultViewport(enabledElement.canvas, image);\n    }\n\n    // merge viewport\n    if(viewport) {\n        for(var attrname in viewport)\n        {\n            if(viewport[attrname] !== null) {\n                enabledElement.viewport[attrname] = viewport[attrname];\n            }\n        }\n    }\n\n    var now = new Date();\n    var frameRate;\n    if(enabledElement.lastImageTimeStamp !== undefined) {\n        var timeSinceLastImage = now.getTime() - enabledElement.lastImageTimeStamp;\n        frameRate = (1000 / timeSinceLastImage).toFixed();\n    }\n    enabledElement.lastImageTimeStamp = now.getTime();\n\n    var newImageEventData = {\n        viewport : enabledElement.viewport,\n        element : enabledElement.element,\n        image : enabledElement.image,\n        enabledElement : enabledElement,\n        frameRate : frameRate\n    };\n\n    var event = new CustomEvent(\"CornerstoneNewImage\", {detail: newImageEventData});\n    enabledElement.element.dispatchEvent(event);\n\n    updateImage(element);\n}\n","/**\n * This module is responsible for immediately drawing an enabled element\n */\n\nimport { getEnabledElement } from './enabledElements.js';\nimport { drawImage } from './internal/drawImage.js';\n\n/**\n * Immediately draws the enabled element\n *\n * @param element\n */\nexport function draw(element) {\n    var enabledElement = getEnabledElement(element);\n\n    if(enabledElement.image === undefined) {\n        throw \"draw: image has not been loaded yet\";\n    }\n\n    drawImage(enabledElement);\n}\n","/**\n * This module is responsible for drawing invalidated enabled elements\n */\n\nimport { getEnabledElements } from './enabledElements.js';\nimport { drawImage } from './internal/drawImage.js';\n\n/**\n * Draws all invalidated enabled elements and clears the invalid flag after drawing it\n */\nexport function drawInvalidated()\n{\n    var enabledElements = getEnabledElements();\n    for(var i=0;i < enabledElements.length; i++) {\n        var ee = enabledElements[i];\n        if(ee.invalid === true) {\n            drawImage(ee, true);\n        }\n    }\n}\n","/**\n * This module will fit an image to fit inside the canvas displaying it such that all pixels\n * in the image are viewable\n */\n\nimport { getEnabledElement } from './enabledElements.js';\nimport { updateImage } from './updateImage.js';\n\nfunction getImageSize(enabledElement) {\n  if(enabledElement.viewport.rotation === 0 ||enabledElement.viewport.rotation === 180) {\n    return {\n      width: enabledElement.image.width,\n      height: enabledElement.image.height\n    };\n  } else {\n    return {\n      width: enabledElement.image.height,\n      height: enabledElement.image.width\n    };\n  }\n}\n\n/**\n * Adjusts an images scale and center so the image is centered and completely visible\n * @param element\n */\nexport function fitToWindow(element)\n{\n    var enabledElement = getEnabledElement(element);\n    var imageSize = getImageSize(enabledElement);\n\n    var verticalScale = enabledElement.canvas.height / imageSize.height;\n    var horizontalScale= enabledElement.canvas.width / imageSize.width;\n    if(horizontalScale < verticalScale) {\n      enabledElement.viewport.scale = horizontalScale;\n    }\n    else\n    {\n      enabledElement.viewport.scale = verticalScale;\n    }\n    enabledElement.viewport.translation.x = 0;\n    enabledElement.viewport.translation.y = 0;\n    updateImage(element);\n}\n","import { getEnabledElement } from './enabledElements.js';\nimport { fitToWindow } from './fitToWindow.js';\nimport { updateImage } from './updateImage.js';\n\n/**\n * This module is responsible for enabling an element to display images with cornerstone\n */\nfunction setCanvasSize(element, canvas)\n{\n    // the device pixel ratio is 1.0 for normal displays and > 1.0\n    // for high DPI displays like Retina\n    /*\n\n    This functionality is disabled due to buggy behavior on systems with mixed DPI's.  If the canvas\n    is created on a display with high DPI (e.g. 2.0) and then the browser window is dragged to\n    a different display with a different DPI (e.g. 1.0), the canvas is not recreated so the pageToPixel\n    produces incorrect results.  I couldn't find any way to determine when the DPI changed other than\n    by polling which is not very clean.  If anyone has any ideas here, please let me know, but for now\n    we will disable this functionality.  We may want\n    to add a mechanism to optionally enable this functionality if we can determine it is safe to do\n    so (e.g. iPad or iPhone or perhaps enumerate the displays on the system.  I am choosing\n    to be cautious here since I would rather not have bug reports or safety issues related to this\n    scenario.\n\n    var devicePixelRatio = window.devicePixelRatio;\n    if(devicePixelRatio === undefined) {\n        devicePixelRatio = 1.0;\n    }\n    */\n\n    canvas.width = element.clientWidth;\n    canvas.height = element.clientHeight;\n    canvas.style.width = element.clientWidth + \"px\";\n    canvas.style.height = element.clientHeight + \"px\";\n}\n\n/**\n * resizes an enabled element and optionally fits the image to window\n * @param element\n * @param useFitToWindow true to refit, false to leave viewport parameters as they are\n */\nexport function resize(element, useFitToWindow) {\n\n    var enabledElement = getEnabledElement(element);\n\n    setCanvasSize(element, enabledElement.canvas);\n\n    if(enabledElement.image === undefined ) {\n        return;\n    }\n\n    if(useFitToWindow === true) {\n        fitToWindow(element);\n    }\n    else {\n        updateImage(element);\n    }\n}\n","/**\n * This module is responsible for enabling an element to display images with cornerstone\n */\n\nimport { addEnabledElement } from './enabledElements.js';\nimport { resize } from './resize.js';\nimport { requestAnimationFrame } from './internal/requestAnimationFrame.js';\n\nexport function enable(element) {\n    if(element === undefined) {\n        throw \"enable: parameter element cannot be undefined\";\n    }\n\n    var canvas = document.createElement('canvas');\n    element.appendChild(canvas);\n\n    var el = {\n        element: element,\n        canvas: canvas,\n        image : undefined, // will be set once image is loaded\n        invalid: false, // true if image needs to be drawn, false if not\n        needsRedraw:true,\n        data : {}\n    };\n    addEnabledElement(el);\n\n    resize(element, true);\n\n\n    function draw() {\n        if (el.canvas === undefined){\n            return;\n        }\n        if (el.needsRedraw && el.image !== undefined){\n            var start = new Date();\n            el.image.render(el, el.invalid);\n\n            var context = el.canvas.getContext('2d');\n\n            var end = new Date();\n            var diff = end - start;\n\n            var eventData = {\n                viewport: el.viewport,\n                element: el.element,\n                image: el.image,\n                enabledElement: el,\n                canvasContext: context,\n                renderTimeInMs: diff\n            };\n\n            var event = new CustomEvent(\"CornerstoneImageRendered\", {detail: eventData});\n            el.element.dispatchEvent(event);\n            el.invalid = false;\n            el.needsRedraw = false;\n        }\n\n        requestAnimationFrame(draw);\n    }\n\n    draw();\n\n    return element;\n}\n","import { getEnabledElement } from './enabledElements.js';\n\nexport function getElementData(el, dataType) {\n    var ee = getEnabledElement(el);\n    if(ee.data.hasOwnProperty(dataType) === false)\n    {\n        ee.data[dataType] = {};\n    }\n    return ee.data[dataType];\n}\n\nexport function removeElementData(el, dataType) {\n    var ee = getEnabledElement(el);\n    delete ee.data[dataType];\n}\n","/**\n * This file is responsible for returning the default viewport for an image\n */\n\nimport { getEnabledElement } from './enabledElements.js';\nimport { getDefaultViewport } from './internal/getDefaultViewport.js';\n\n/**\n * returns a default viewport for display the specified image on the specified\n * enabled element.  The default viewport is fit to window\n *\n * @param element\n * @param image\n */\nexport function getDefaultViewportForImage(element, image) {\n    var enabledElement = getEnabledElement(element);\n    var viewport = getDefaultViewport(enabledElement.canvas, image);\n    return viewport;\n}\n","/**\n * This module is responsible for returning the currently displayed image for an element\n */\n\nimport { getEnabledElement } from './enabledElements.js';\n\n/**\n * returns the currently displayed image for an element or undefined if no image has\n * been displayed yet\n *\n * @param element\n */\nexport function getImage(element) {\n    var enabledElement = getEnabledElement(element);\n    return enabledElement.image;\n}\n","/**\n * This module returns a subset of the stored pixels of an image\n */\n\nimport { getEnabledElement } from './enabledElements.js';\n\n/**\n * Returns an array of stored pixels given a rectangle in the image\n * @param element\n * @param x\n * @param y\n * @param width\n * @param height\n * @returns {Array}\n */\nexport function getStoredPixels(element, x, y, width, height) {\n    if(element === undefined) {\n        throw \"getStoredPixels: parameter element must not be undefined\";\n    }\n\n    x = Math.round(x);\n    y = Math.round(y);\n    var ee = getEnabledElement(element);\n    var storedPixels = [];\n    var index = 0;\n    var pixelData = ee.image.getPixelData();\n    for(var row=0; row < height; row++) {\n        for(var column=0; column < width; column++) {\n            var spIndex = ((row + y) * ee.image.columns) + (column + x);\n            storedPixels[index++] = pixelData[spIndex];\n        }\n    }\n    return storedPixels;\n}\n","/**\n * This module returns a subset of the stored pixels of an image\n */\n\nimport { getEnabledElement } from './enabledElements.js';\nimport { getStoredPixels } from './getStoredPixels.js';\nimport { getModalityLUT } from './internal/modalityLUT.js';\n\n/**\n * Returns array of pixels with modality LUT transformation applied\n */\nexport function getPixels(element, x, y, width, height) {\n\n    var storedPixels = getStoredPixels(element, x, y, width, height);\n    var ee = getEnabledElement(element);\n\n    var mlutfn = getModalityLUT(ee.image.slope, ee.image.intercept, ee.viewport.modalityLUT);\n\n    var modalityPixels = storedPixels.map(mlutfn);\n\n    return modalityPixels;\n}\n","/**\n * This module contains functions to deal with getting and setting the viewport for an enabled element\n */\n\nimport { getEnabledElement } from './enabledElements.js';\n\n/**\n * Returns the viewport for the specified enabled element\n * @param element\n * @returns {*}\n */\nexport function getViewport(element) {\n    var enabledElement = getEnabledElement(element);\n\n    var viewport = enabledElement.viewport;\n    if(viewport === undefined) {\n        return undefined;\n    }\n    return {\n        scale : viewport.scale,\n        translation : {\n            x : viewport.translation.x,\n            y : viewport.translation.y\n        },\n        voi : {\n            windowWidth: viewport.voi.windowWidth,\n            windowCenter : viewport.voi.windowCenter\n        },\n        invert : viewport.invert,\n        pixelReplication: viewport.pixelReplication,\n        rotation: viewport.rotation,\n        hflip: viewport.hflip,\n        vflip: viewport.vflip,\n        modalityLUT: viewport.modalityLUT,\n        voiLUT: viewport.voiLUT\n    };\n}\n","/**\n * This module deals with caching images\n */\nimport { dispatchEvent } from './addEventListener.js';\n\n// dictionary of sharedCacheKeys to number of imageId's in cache with this shared cache key\nvar sharedCacheKeys = {};\n\nvar maximumSizeInBytes = 1024 * 1024 * 1024; // 1 GB\nvar cacheSizeInBytes = 0;\n\n// dictionary of imageId to cachedImage objects\nexport const imageCache = {};\n// array of cachedImage objects\nexport const cachedImages = [];\n\nexport function setMaximumSizeBytes(numBytes) {\n    if (numBytes === undefined) {\n        throw \"setMaximumSizeBytes: parameter numBytes must not be undefined\";\n    }\n    if (numBytes.toFixed === undefined) {\n        throw \"setMaximumSizeBytes: parameter numBytes must be a number\";\n    }\n\n    maximumSizeInBytes = numBytes;\n    purgeCacheIfNecessary();\n}\n\nfunction purgeCacheIfNecessary() {\n\n    // if max cache size has not been exceeded, do nothing\n    if (cacheSizeInBytes <= maximumSizeInBytes) {\n        return;\n    }\n\n    // cache size has been exceeded, create list of images sorted by timeStamp\n    // so we can purge the least recently used image\n    function compare(a,b) {\n        if (a.timeStamp > b.timeStamp) {\n            return -1;\n        }\n        if (a.timeStamp < b.timeStamp) {\n            return 1;\n        }\n        return 0;\n    }\n    cachedImages.sort(compare);\n\n    // remove images as necessary\n    while(cacheSizeInBytes > maximumSizeInBytes) {\n        var lastCachedImage = cachedImages[cachedImages.length - 1];\n        cacheSizeInBytes -= lastCachedImage.sizeInBytes;\n        delete imageCache[lastCachedImage.imageId];\n        lastCachedImage.imagePromise.reject();\n        cachedImages.pop();\n        dispatchEvent(\"CornerstoneImageCachePromiseRemoved\", {imageId: lastCachedImage.imageId});\n    }\n\n    var cacheInfo = getCacheInfo();\n    dispatchEvent(\"CornerstoneImageCacheFull\", cacheInfo);\n}\n\nexport function putImagePromise(imageId, imagePromise) {\n    if (imageId === undefined) {\n        throw \"getImagePromise: imageId must not be undefined\";\n    }\n    if (imagePromise === undefined) {\n        throw \"getImagePromise: imagePromise must not be undefined\";\n    }\n\n    if (imageCache.hasOwnProperty(imageId) === true) {\n        throw \"putImagePromise: imageId already in cache\";\n    }\n\n    var cachedImage = {\n        loaded : false,\n        imageId : imageId,\n        sharedCacheKey: undefined, // the sharedCacheKey for this imageId.  undefined by default\n        imagePromise : imagePromise,\n        timeStamp : new Date(),\n        sizeInBytes: 0\n    };\n\n    imageCache[imageId] = cachedImage;\n    cachedImages.push(cachedImage);\n\n    imagePromise.then(function(image) {\n        cachedImage.loaded = true;\n        cachedImage.image = image;\n\n        if (image.sizeInBytes === undefined) {\n            throw \"putImagePromise: image does not have sizeInBytes property or\";\n        }\n        if (image.sizeInBytes.toFixed === undefined) {\n            throw \"putImagePromise: image.sizeInBytes is not a number\";\n        }\n\n        // If this image has a shared cache key, reference count it and only\n        // count the image size for the first one added with this sharedCacheKey\n        if(image.sharedCacheKey) {\n          cachedImage.sizeInBytes = image.sizeInBytes;\n          cachedImage.sharedCacheKey = image.sharedCacheKey;\n          if(sharedCacheKeys[image.sharedCacheKey]) {\n            sharedCacheKeys[image.sharedCacheKey]++;\n          } else {\n            sharedCacheKeys[image.sharedCacheKey] = 1;\n            cacheSizeInBytes += cachedImage.sizeInBytes;\n          }\n        }\n        else {\n          cachedImage.sizeInBytes = image.sizeInBytes;\n          cacheSizeInBytes += cachedImage.sizeInBytes;\n        }\n        purgeCacheIfNecessary();\n    });\n}\n\nexport function getImagePromise(imageId) {\n    if (imageId === undefined) {\n        throw \"getImagePromise: imageId must not be undefined\";\n    }\n    var cachedImage = imageCache[imageId];\n    if (cachedImage === undefined) {\n        return undefined;\n    }\n\n    // bump time stamp for cached image\n    cachedImage.timeStamp = new Date();\n    return cachedImage.imagePromise;\n}\n\nexport function removeImagePromise(imageId) {\n    if (imageId === undefined) {\n        throw \"removeImagePromise: imageId must not be undefined\";\n    }\n    var cachedImage = imageCache[imageId];\n    if (cachedImage === undefined) {\n        throw \"removeImagePromise: imageId must not be undefined\";\n    }\n    cachedImages.splice( cachedImages.indexOf(cachedImage), 1);\n\n    // If this is using a sharedCacheKey, decrement the cache size only\n    // if it is the last imageId in the cache with this sharedCacheKey\n    if(cachedImage.sharedCacheKey) {\n      if(sharedCacheKeys[cachedImage.sharedCacheKey] === 1) {\n        cacheSizeInBytes -= cachedImage.sizeInBytes;\n        delete sharedCacheKeys[cachedImage.sharedCacheKey];\n      } else {\n        sharedCacheKeys[cachedImage.sharedCacheKey]--;\n      }\n    } else {\n      cacheSizeInBytes -= cachedImage.sizeInBytes;\n    }\n    delete imageCache[imageId];\n\n    decache(cachedImage.imagePromise, cachedImage.imageId);\n\n    return cachedImage.imagePromise;\n}\n\nexport function getCacheInfo() {\n    return {\n        maximumSizeInBytes : maximumSizeInBytes,\n        cacheSizeInBytes : cacheSizeInBytes,\n        numberOfImagesCached: cachedImages.length\n    };\n}\n\nfunction decache(imagePromise, imageId) {\n  imagePromise.then(function(image) {\n    if(image.decache) {\n      image.decache();\n    }\n    imagePromise.reject();\n    delete imageCache[imageId];\n  }).always(function() {\n    delete imageCache[imageId];\n  });\n}\n\nexport function purgeCache() {\n    while (cachedImages.length > 0) {\n      var removedCachedImage = cachedImages.pop();\n      decache(removedCachedImage.imagePromise, removedCachedImage.imageId);\n    }\n    cacheSizeInBytes = 0;\n}\n\nexport function changeImageIdCacheSize(imageId, newCacheSize) {\n  var cacheEntry = imageCache[imageId];\n  if(cacheEntry) {\n    cacheEntry.imagePromise.then(function(image) {\n      var cacheSizeDifference = newCacheSize - image.sizeInBytes;\n      image.sizeInBytes = newCacheSize;\n      cacheSizeInBytes += cacheSizeDifference;\n    });\n  }\n}\n","/**\n * This module deals with ImageLoaders, loading images and caching images\n */\nimport { dispatchEvent } from './addEventListener.js';\nimport { getImagePromise, putImagePromise } from './imageCache.js';\n\nvar imageLoaders = {};\n\nvar unknownImageLoader;\n\nfunction loadImageFromImageLoader(imageId, options) {\n    var colonIndex = imageId.indexOf(\":\");\n    var scheme = imageId.substring(0, colonIndex);\n    var loader = imageLoaders[scheme];\n    var imagePromise;\n    if(loader === undefined || loader === null) {\n        if(unknownImageLoader !== undefined) {\n            imagePromise = unknownImageLoader(imageId);\n            return imagePromise;\n        }\n        else {\n            return undefined;\n        }\n    }\n    imagePromise = loader(imageId, options);\n\n    // broadcast an image loaded event once the image is loaded\n    imagePromise.then(function(image) {\n        dispatchEvent(\"CornerstoneImageLoaded\",  {image: image});\n    });\n\n    return imagePromise;\n}\n\n// Loads an image given an imageId and optional priority and returns a promise which will resolve\n// to the loaded image object or fail if an error occurred.  The loaded image\n// is not stored in the cache\nexport function loadImage(imageId, options) {\n    if(imageId === undefined) {\n        throw \"loadImage: parameter imageId must not be undefined\";\n    }\n\n    var imagePromise = getImagePromise(imageId);\n    if(imagePromise !== undefined) {\n        return imagePromise;\n    }\n\n    imagePromise = loadImageFromImageLoader(imageId, options);\n    if(imagePromise === undefined) {\n        throw \"loadImage: no image loader for imageId\";\n    }\n\n    return imagePromise;\n}\n\n// Loads an image given an imageId and optional priority and returns a promise which will resolve\n// to the loaded image object or fail if an error occurred.  The image is\n// stored in the cache\nexport function loadAndCacheImage(imageId, options) {\n    if(imageId === undefined) {\n        throw \"loadAndCacheImage: parameter imageId must not be undefined\";\n    }\n\n    var imagePromise = getImagePromise(imageId);\n    if(imagePromise !== undefined) {\n        return imagePromise;\n    }\n\n    imagePromise = loadImageFromImageLoader(imageId, options);\n    if(imagePromise === undefined) {\n        throw \"loadAndCacheImage: no image loader for imageId\";\n    }\n\n    putImagePromise(imageId, imagePromise);\n\n    return imagePromise;\n}\n\n\n// registers an imageLoader plugin with cornerstone for the specified scheme\nexport function registerImageLoader(scheme, imageLoader) {\n    imageLoaders[scheme] = imageLoader;\n}\n\n// Registers a new unknownImageLoader and returns the previous one (if it exists)\nexport function registerUnknownImageLoader(imageLoader) {\n    var oldImageLoader = unknownImageLoader;\n    unknownImageLoader = imageLoader;\n    return oldImageLoader;\n}\n","/**\n * This module contains a function to make an image is invalid\n */\n\nimport { getEnabledElement } from './enabledElements.js';\n\n/**\n * Sets the invalid flag on the enabled element and fire an event\n * @param element\n */\nexport function invalidate(element) {\n    var enabledElement = getEnabledElement(element);\n    enabledElement.invalid = true;\n    enabledElement.needsRedraw = true;\n    var eventData = {\n        element: element\n    };\n    var event = new CustomEvent(\"CornerstoneInvalidated\", {detail: eventData});\n    enabledElement.element.dispatchEvent(event);\n}\n","/**\n * This module contains a function to immediately invalidate an image\n */\n\nimport { getEnabledElementsByImageId } from './enabledElements.js';\nimport { drawImage } from './internal/drawImage.js';\n\n/**\n * Forces the image to be updated/redrawn for the specified enabled element\n * @param element\n */\nexport function invalidateImageId(imageId) {\n\n    var enabledElements = getEnabledElementsByImageId(imageId);\n    enabledElements.forEach(function(enabledElement) {\n        drawImage(enabledElement, true);\n    });\n}\n","/**\n * This module contains a helper function to covert page coordinates to pixel coordinates\n */\n\nimport { getTransform } from './internal/getTransform.js';\nimport { getEnabledElement } from './enabledElements.js';\n\n/**\n * Converts a point in the page coordinate system to the pixel coordinate\n * system\n * @param element\n * @param pageX\n * @param pageY\n * @returns {{x: number, y: number}}\n */\nexport function pageToPixel(element, pageX, pageY) {\n    var enabledElement = getEnabledElement(element);\n\n    if(enabledElement.image === undefined) {\n        throw \"image has not been loaded yet\";\n    }\n\n    // convert the pageX and pageY to the canvas client coordinates\n    var rect = element.getBoundingClientRect();\n    var clientX = pageX - rect.left - window.pageXOffset;\n    var clientY = pageY - rect.top - window.pageYOffset;\n\n    var pt = {x: clientX, y: clientY};\n    var transform = getTransform(enabledElement);\n    transform.invert();\n    return transform.transformPoint(pt.x, pt.y);\n}\n","import { getTransform } from './internal/getTransform.js';\nimport { getEnabledElement } from './enabledElements.js';\n\n/**\n * Converts a point in the pixel coordinate system to the canvas coordinate system\n * system.  This can be used to render using canvas context without having the weird\n * side effects that come from scaling and non square pixels\n * @param element\n * @param pt\n * @returns {x: number, y: number}\n */\nexport function pixelToCanvas(element, pt) {\n    var enabledElement = getEnabledElement(element);\n    var transform = getTransform(enabledElement);\n    return transform.transformPoint(pt.x, pt.y);\n}\n","import { getDefaultViewport } from './internal/getDefaultViewport.js';\nimport { getEnabledElement } from './enabledElements.js';\nimport { updateImage } from './updateImage.js';\n\n/**\n * Resets the viewport to the default settings\n *\n * @param element\n */\nexport function reset(element)\n{\n  var enabledElement = getEnabledElement(element);\n  var defaultViewport = getDefaultViewport(enabledElement.canvas, enabledElement.image);\n  enabledElement.viewport = defaultViewport;\n  updateImage(element);\n}\n","/**\n * This module contains functions to deal with getting and setting the viewport for an enabled element\n */\n\nimport { getEnabledElement } from './enabledElements.js';\nimport { updateImage } from './updateImage.js';\n\n/**\n * Sets the viewport for an element and corrects invalid values\n *\n * @param element - DOM element of the enabled element\n * @param viewport - Object containing the viewport properties\n * @returns {*}\n */\nexport function setViewport(element, viewport) {\n\n    var enabledElement = getEnabledElement(element);\n\n    enabledElement.viewport.scale = viewport.scale;\n    enabledElement.viewport.translation.x = viewport.translation.x;\n    enabledElement.viewport.translation.y = viewport.translation.y;\n    enabledElement.viewport.voi.windowWidth = viewport.voi.windowWidth;\n    enabledElement.viewport.voi.windowCenter = viewport.voi.windowCenter;\n    enabledElement.viewport.invert = viewport.invert;\n    enabledElement.viewport.pixelReplication = viewport.pixelReplication;\n    enabledElement.viewport.rotation = viewport.rotation;\n    enabledElement.viewport.hflip = viewport.hflip;\n    enabledElement.viewport.vflip = viewport.vflip;\n    enabledElement.viewport.modalityLUT = viewport.modalityLUT;\n    enabledElement.viewport.voiLUT = viewport.voiLUT;\n\n    // prevent window width from being too small (note that values close to zero are valid and can occur with\n    // PET images in particular)\n    if(enabledElement.viewport.voi.windowWidth < 0.000001) {\n        enabledElement.viewport.voi.windowWidth = 0.000001;\n    }\n    // prevent scale from getting too small\n    if(enabledElement.viewport.scale < 0.0001) {\n        enabledElement.viewport.scale = 0.25;\n    }\n\n    if(enabledElement.viewport.rotation===360 || enabledElement.viewport.rotation===-360) {\n        enabledElement.viewport.rotation = 0;\n    }\n\n    // Force the image to be updated since the viewport has been modified\n    updateImage(element);\n}\n","// this module defines a way to access various metadata about an imageId.  This layer of abstraction exists\n// so metadata can be provided in different ways (e.g. by parsing DICOM P10 or by a WADO-RS document)\n\nvar providers = [];\n\n/**\n * Adds a metadata provider with the specified priority\n * @param provider\n * @param priority - 0 is default/normal, > 0 is high, < 0 is low\n */\nexport function addProvider(provider, priority) {\n  priority = priority || 0; // default priority\n  // find the right spot to insert this provider based on priority\n  for(var i=0; i < providers.length; i++) {\n    if(providers[i].priority <= priority) {\n      break;\n    }\n  }\n\n  // insert the decode task at position i\n  providers.splice(i, 0, {\n    priority: priority,\n    provider: provider\n  });\n\n}\n\n/**\n * Removes the specified provider\n * @param provider\n */\nexport function removeProvider( provider) {\n  for(var i=0; i < providers.length; i++) {\n    if(providers[i].provider === provider) {\n      providers.splice(i, 1);\n      return;\n    }\n  }\n}\n\n/**\n * Gets metadata from the registered metadata providers.  Will call each one from highest priority to lowest\n * until one responds\n *\n * @param type\n * @param imageId\n * @returns {boolean}\n */\nexport function getMetaData(type, imageId) {\n  // invoke each provider in priority order until one returns something\n  for(var i=0; i < providers.length; i++) {\n    var result;\n    result = providers[i].provider(type, imageId);\n    if (result !== undefined) {\n      return result;\n    }\n  }\n}\nexport const get = getMetaData; // api compatibility\n","export const VERSION = '<@VERSION@>';\n\n// internal (some of these are from old internal/legacy.js expose)\nexport { drawImage } from './internal/drawImage.js';\nexport { generateLut, generateLutNew } from './internal/generateLut.js';\nexport { getDefaultViewport } from './internal/getDefaultViewport.js';\nexport { requestAnimationFrame } from './internal/requestAnimationFrame.js';\nexport {\n  storedPixelDataToCanvasImageData\n} from './internal/storedPixelDataToCanvasImageData.js';\nexport {\n  storedColorPixelDataToCanvasImageData\n} from './internal/storedColorPixelDataToCanvasImageData.js';\n\n// rendering\nimport { renderColorImage } from './rendering/renderColorImage.js';\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage.js';\nimport { renderWebImage } from './rendering/renderWebImage.js';\nexport { renderColorImage, renderGrayscaleImage, renderWebImage };\nexport const rendering = {\n  colorImage: renderColorImage,\n  grayscaleImage: renderGrayscaleImage,\n  webImage: renderWebImage,\n};\n\nexport { addEventListener, dispatchEvent } from './addEventListener.js';\nexport { canvasToPixel } from './canvasToPixel.js';\nexport { disable } from './disable.js';\nexport { displayImage } from './displayImage.js';\nexport { draw } from './draw.js';\nexport { drawInvalidated } from './drawInvalidated.js';\nexport { enable } from './enable.js';\nexport { getElementData, removeElementData } from './enabledElementData.js';\nexport {\n  getEnabledElement,\n  addEnabledElement,\n  getEnabledElementsByImageId,\n  getEnabledElements\n} from './enabledElements.js';\nexport { fitToWindow } from './fitToWindow.js';\nexport { getDefaultViewportForImage } from './getDefaultViewportForImage.js';\nexport { getImage } from './getImage.js';\nexport { getPixels } from './getPixels.js';\nexport { getStoredPixels } from './getStoredPixels.js';\nexport { getViewport } from './getViewport.js';\nexport {\n  loadImage,\n  loadAndCacheImage,\n  registerImageLoader,\n  registerUnknownImageLoader\n} from './imageLoader.js';\nexport { invalidate } from './invalidate.js';\nexport { invalidateImageId } from './invalidateImageId.js';\nexport { pageToPixel } from './pageToPixel.js';\nexport { pixelToCanvas } from './pixelToCanvas.js';\nexport { reset } from './reset.js';\nexport { resize } from './resize.js';\nexport { setToPixelCoordinateSystem } from './setToPixelCoordinateSystem.js';\nexport { setViewport } from './setViewport.js';\nexport { updateImage } from './updateImage.js';\n\n// funky exports, same api as before es6\nimport {\n  imageCache as imageCacheDict, cachedImages, setMaximumSizeBytes, putImagePromise,\n  getImagePromise, removeImagePromise, getCacheInfo, purgeCache,\n  changeImageIdCacheSize,\n} from './imageCache.js';\nexport const imageCache = {\n  imageCache: imageCacheDict, cachedImages, setMaximumSizeBytes, putImagePromise,\n  getImagePromise, removeImagePromise, getCacheInfo, purgeCache,\n  changeImageIdCacheSize\n};\nimport { addProvider, removeProvider, get } from './metaData.js';\nexport const metaData = { addProvider, removeProvider, get };\n"],"names":["drawImage","enabledElement","invalidated","needsRedraw","invalid","generateLinearModalityLUT","slope","intercept","localSlope","localIntercept","sp","generateNonLinearModalityLUT","modalityLUT","minValue","lut","maxValue","length","maxValueMapped","firstValueMapped","getModalityLUT","generateLinearVOILUT","windowWidth","windowCenter","modalityLutValue","generateNonLinearVOILUT","voiLUT","shift","numBitsPerEntry","getVOILUT","generateLutNew","image","invert","undefined","Int16Array","maxPixelValue","Math","min","minPixelValue","mlutfn","vlutfn","offset","storedValue","voiLutValue","clampedValue","max","round","generateLut","localWindowWidth","localWindowCenter","getDefaultViewport","canvas","viewport","verticalScale","height","rows","horizontalScale","width","columns","scale","requestFrame","callback","setTimeout","requestAnimationFrame","window","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","storedPixelDataToCanvasImageData","canvasImageDataData","pixelData","getPixelData","canvasImageDataIndex","storedPixelDataIndex","localNumPixels","localPixelData","localLut","localCanvasImageDataData","storedColorPixelDataToCanvasImageData","numPixels","storedPixelData","Transform","reset","calculateTransform","transform","translate","angle","rotation","rotate","PI","widthScale","heightScale","rowPixelSpacing","columnPixelSpacing","translation","x","y","hflip","vflip","setToPixelCoordinateSystem","context","setTransform","m","initializeColorRenderCanvas","colorRenderCanvas","getContext","fillStyle","fillRect","colorRenderCanvasContext","getImageData","getLut","voi","doesImageNeedToBeRendered","imageId","lastRenderedImageId","lastRenderedViewport","getRenderCanvas","getCanvas","colorRenderCanvasData","data","putImageData","renderColorImage","pixelReplication","imageSmoothingEnabled","mozImageSmoothingEnabled","save","renderCanvas","restore","initializeGrayscaleRenderCanvas","grayscaleRenderCanvas","grayscaleRenderCanvasContext","lutMatches","a","b","id","grayscaleRenderCanvasData","renderGrayscaleImage","renderWebImage","getImage","addEventListener","type","eventListeners","eventTypes","push","dispatchEvent","i","getEnabledElement","element","enabledElements","addEnabledElement","getEnabledElementsByImageId","ees","forEach","getEnabledElements","getTransform","canvasToPixel","pt","transformPoint","disable","eventData","event","CustomEvent","detail","removeChild","splice","updateImage","displayImage","attrname","frameRate","now","Date","lastImageTimeStamp","getTime","toFixed","newImageEventData","draw","drawInvalidated","ee","getImageSize","fitToWindow","imageSize","setCanvasSize","clientWidth","clientHeight","style","resize","useFitToWindow","enable","el","start","render","end","diff","document","createElement","appendChild","getElementData","dataType","hasOwnProperty","removeElementData","getDefaultViewportForImage","getStoredPixels","storedPixels","index","row","column","spIndex","getPixels","map","getViewport","setMaximumSizeBytes","numBytes","purgeCacheIfNecessary","compare","timeStamp","cacheSizeInBytes","maximumSizeInBytes","sort","lastCachedImage","cachedImages","sizeInBytes","imageCache","imagePromise","reject","pop","getCacheInfo","putImagePromise","cachedImage","then","loaded","sharedCacheKey","sharedCacheKeys","getImagePromise","removeImagePromise","indexOf","decache","always","purgeCache","removedCachedImage","changeImageIdCacheSize","newCacheSize","cacheEntry","cacheSizeDifference","loadImageFromImageLoader","options","colonIndex","scheme","substring","loader","imageLoaders","unknownImageLoader","loadImage","loadAndCacheImage","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","invalidate","invalidateImageId","pageToPixel","pageX","pageY","rect","getBoundingClientRect","clientX","left","pageXOffset","clientY","top","pageYOffset","pixelToCanvas","defaultViewport","setViewport","addProvider","provider","priority","providers","removeProvider","getMetaData","result","prototype","clone","this","multiply","matrix","m11","m12","m21","m22","dx","dy","d","m0","m1","m2","m3","m4","m5","rad","c","cos","s","sin","sx","sy","px","py","get","rendering","imageCacheDict","metaData"],"mappings":"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"}